

======================== 基本设置 =================================================================
swift可以无缝地与Cocoa和Objective-C结合.  可以在swift中用ObjC API,也可以在ObjC中使用swift API.

	1.互用
	2.混合与匹配
	3.迁移

1. 设置你的Swift环境
	新建项目->选择语言:swift 
	项目与ObjC的不同: 没有.h.m(没有明确的轮廓), 只有.swift

	swift开发注意平台版本问题,太早的平台版本会报错. iOS7,OSX10.9
	

2. 理解swift导入(import)过程
	格式为:
	import Foundation
	
  过程解释:
	ObjC的框架API都在.h文件中,swift会把这些.h文件编译进Objc内容的模块中, 再import进来作为swift API. (swift导入的都是模块)
	import过程决定ObjC中声明的函数/类/方法/类型等如何展现在swift中.
	
	函数和方法的参数和返回值:
		类型相当, 如  		id <--> AnyObject		都是class引用类型
		核心类型to替代, 如 	NSString <--> String
		思想替代, 如 		指针 <--> 可选类型
		
	注意: swift不能导入C++代码. 如需要C++库, 则要用Objc或C给它作层封装,再导入.
	
	ObjC中导入swift:
		swift模型会生成.h文件, ObjC中导入这个.h就行了.
	
	
	
================= 两种语言间 互操作性 =====================================
swift & ObjC 用某种语言写的文件内可以使用另一种语言.
很重要一方面是swift可使用ObjC API.


1.构造方法
	ObjC的构方
		定义: 
		-(instancetype)initWithFrame:(CGRect)frame style:(UITableViewStyle)style
		调用:
		UITableView *tableView = [[UITableView alloc] initWithFrame:rect style:UITableViewStyleXX]
		
	swift的构方:(更接近java)
		定义:
		init(){}    init(frame:CGRect,style:UITableViewStyle){...}
		调用:
		let tableView:UITableView = UITableView(frame:rect,style:UITableViewStyleXX)
	
	--java的构方的定义和调用都是className; swift的定义是init,调用是className


1.1 OC工厂构方是swift便利构方:
	还记得swift中的直接构方和便利构方吗? 继承与调用关系?
	OC中的多态构方(工厂构方)在swift中都是便利构方
	示例:
		UIColor *color = [UIColor colorWithRed:0.5 green:0.5 blue:0.5 alpha:1.0]
		let color:UIColor = UIColor(red:0.5,green:0.5,blue:0.5,alpha:1.0)	--
		
	--colorWithRed:直接是便利构方使用, 其他ObjC类都可这样用.
	
	
1.2 可失败构方
	ObjC中构方失败会直接返回nil, swift中此功能被整成可失败构方的特性.
	示例:  
	if let image = UIImage(contentsOfFile:"") {				--[UIImage imageWithName:@""]
	} else {
	}
	
		
		
2. 访问属性
	导入OC中@property定义的属性进入swift可用以下方式:
	1. OC中定义成nonull,nullable和null_resettable的属性导入后为?或!型
	2. OC中readonly属性-->{get}的计算型属性
	3. OC中weak属性 -->  weak var ..
	4. OC中非weak属性(retain,copy,strong,unsage_unretaining等) 转换为相应属性
	5. 原子属性(nonatomic,atomic)无对应, 但在OC中声明的原子属性在swift中仍然生效.
	6. 访问属性(getter=,setter=)在swift中被忽略,无效
	
	
	
3. 调用方法
	改成点号调用
	[tableView insertSubView:subView  atIndex:2]
	tableView.insertSubView(subView, atIndex:2)
	
4. id兼容性
	var object:AnyObject = UITableViewCell()	
	object = NSDate()					--定义成AnyObject后可以更改类型
	object.characterAtIndex(1)			--NSDate无此方法, 但编译正常, 运行时才报错. 因为是AnyObject类型的
	
	--AnyObject调用属性或方法都是?型的. 方法调用要带?号: object.mtd?(arg) 
	--记得可选链吗?  aa?.mtd?().mtd2?().count?.property   --好像是这样
	
	
4.1 强制转换AnyObject
	let object:AnyObject? = userDefaults.objectForKey("xx")		--KVO返回的都是id/AnyObject
	if let date=object as? NSDate {								--用 as?+if 转换类型. 
		//转换成功后代码
	}
	如明确知道类型,则不用if,直接as!转 
	let date = object as!NSDate; 	date.mtd()
	let str = object as!NSString 		--转换出错
	
	
	
5. 可空和可选的属性
	ObjC可用非空声明决定属性,参数,返回值是否可为空. 甚至用NS_ASSUME_NONNULL_BEGIN宏命令...
	swift导入后, nonnull为非空(啥都不加的), nullable为?, 没加则默认为打开的可选型 (?)!
	
	@property (nullable) id nullableProperty;
	@property (nonnull) id nonNullProperty;
	@property id unannotatedProperty;				--未修饰的
	
	var nullableProperty: AnyObject?			--
	var nonNullProperty: AnyObject				--
	var unannotatedProperty: AnyObject!			--未加的, 默认为!后的可选类型(原类型仍是可选类型)
	
	- (nullable id)returnsNullableValue;
	- (void)takesNullableParameter:(nullable id)value;
	func returnsNullableValue() -> AnyObject?
	func takesNullableParameter(value: AnyObject?)
	
	- (id)returnsUnannotatedValue;
	- (void)takesUnannotatedParameter:(id)value;			
	func returnsUnannotatedValue() -> AnyObject!
	func takesUnannotatedParameter(value: AnyObject!)		--这种的要注意, 不加的反而是!的
	
	
	
6. ObjC中轻量级泛型
	主要在集合类型中
	@property NSArray<NSDate *> *dates;							--OC中几类集合泛型
	@property NSSet<NSString *> *words;
	@property NSDictionary<NSURL *, NSData *> *cachedData;	
	
	var dates: [NSDate]
	var words: Set<String>									--Set仍然是<>, 数组和字典只用[]就好了.
	var cachedData: [NSURL: NSData]
	
	注意: ObjC集合的轻量级泛型在swift中是忽略的.导入后是不带泛型的集合
	

7. 扩展
	同ObjC中的catagory相似. 都可以扩展class,struct,enum
	在swift中导入OC模块后, 即可扩展其中类型.
	示例:
	extension UIColor {
		convenience init(onlyRed:Double,alpha:Double) {
			self.init()
			self.red = onlyRed; self.green = 1.0; self.blue = 1.0
		}
	}
	
	还可扩展: 计算型属性; override属性,方法; 让某类实现协议一致性;
	
	
	
8. 闭包
	OC的闭包会自动转换为swift的闭包.    @convention(block)
	void (^completionBlock)(NSData *, NSError *) = ^(NSData *data, NSError *error) {
	}
	--括号里的竟然是名字
	let completionBlock: (NSData, NSError) -> Void = { data, error in
	}
	--{}内参数后in,后竟然是代码..
	
	--两种闭包通用, OC的方法需要闭包参数可传swift闭包, swift方法参数也可传OC闭包.
	
	
	
8.1 避免strong循环,当捕获自身时
	闭包是引用类型. self强引用闭包, 闭包体强引用self属性/方法.
	OC:
		__weak typeof(self) weakSelf = self;		--OC中先取个self变成weak,在block里再变成strong,再实现代码
		self.block = ^{
		   __strong typeof(self) strongSelf = weakSelf;
		   [strongSelf doSomething];
		};
	swift:
		self.closure = { [unowned self] in		--swift的闭包循环直接用[unowned self]即可
			self.doSomething()
		}
		
		
9. 对象比较
	内容比较==, 等于调用NSObject的isEqual方法
	身份比较===,等于判断指针是否同一个
	实现Equatable协议 + 继承NSObject类.
	实现Hashable协议 + 继承NSObject类和类中hashValue属性, 
	
	
	
10. swift类型兼容性
	当创建了继承自OC类的swift类时, 类和成员都自动和OC的兼容. 但排除swift自有的特性:
		泛型
		元组: (1,2,3)
		枚举,原始值不是Int型的.
		struct,定义在swift中的
		顶层函数,定义在swift中的
		全局变量,定义在swift中的
		类型命名,定义在swift中的
		嵌套类型
		
	swift类型自动转向OC:
		可选类型 -> nullable,  非空 -> nonnull
		swift常量变量,方法,构方 -> OC的相应成员
		抛异常方法 -> NSError,
		
	示例: swift文件中, swift与OC结合
		class SomeClass:NSObject{
			var library:Set<String>
			var name:String?				--可选  nullable
			var isCurrent:Bool{
				return name==nil			--计算型属性
			}
			init(name:String?){				--可选型
				self?.name = name
			}
			init(lib:String...){
				self.library = Set<String>(lib)			--用...的竟然可以直接为Set
			}
		}
	OC代码则为: .h
		@interface SomeClass:NSObject{
		@property (nonatomic, copy) NSSet<NSString *> * __nonnull library;
		@property (nonatomic, copy) NSString * __nullable name ;
		@property (nonatomic, readonly) BOOL isCurrent;
		-(nonnull instancetype)initWithName:(NSString* __nullable) name ;
		-(nonnull instancetype)initWithLib:(Set<NSString*> *__nonnull) lib;
		}
			
	注意: 不能在OC中继承一个swift类.
	
	
	
	
10.1 配置swift代码以暴露成员给ObjC:
	有时需要更好地把swiftAPI暴露给OC, 可以在swift中加上@objc(name)注解使swift的类/属性/方法,枚举类/枚举例
	暴露给OC.
	
	示例:
	@objc(Color)			--枚举类名
	enum ыйЦ {				--swift命名任意unicode,OC必须英文数字
		@objc(red)			--枚举item名
		case Черн
	}
	@objc(Person)			--类名
	class 人类: NSObject{
		@objc(color)		--属性名
		var 乱码:ыйЦ =  .Черн
		
		@objc(initWithName:)		--参数加:号
		init(name:String) {
		}
		
		@objc(mtdByArg:withArg2:)
		func 乱码方法(乱码名:Int  乱码2:乱码类型){
		}
	}
	
	
10.2 动态分配 
	当OC在运行时导入swiftAPI,没有保证动态分配成员. swift为保性能会绕开OC.
	dynamic 修饰, 但是极少需要用到的.
	
	
11. OC的选择器Selector:
	OC的SEL是引用到一个方法.  在swift中可以用#selector()表达式.
	示例:
		let mySelector = #selector(MyViewController.tappedButton)		
		
	OC中的方法可被加上(),然后用as来转义消除歧义:
	let anotherSel = #selector(((UIView.insertSubView(_:at:)) as (UIView)->(UIView,Int)->Void))
		--仅是用as消除歧义的. 本质还是调用insertSubView
		
	完整类示例:
	import UIKit
	class myUIViewController:UIViewController{
		let myBtn = UIButton(xx)
		override init?(x:y){
			super.init(x:y)
			let action = #selector(myUIViewController.tappedButton)		--自己的方法也要: 类名.方法
			myBtn.addTarget(self,action:action, xx)
		}
		func tappedButton(sender:UIButton){}
	}
	
	
11.1 用performSelector发送消息
	可以在swift中调用NSObject.performSelector()系列方法向ObjC对象发送消息.
	performSelectorAPI能同步地发消息至特定的线程, or在一个延迟之后. (哇, 能跨线程发送, 还能发送给延迟过程呀)
	
	-(void)performSelector:(SEL)aSelector
             withObject:(id)anArgument
             afterDelay:(NSTimeInterval)delay			--给定延时时间发送
			inModes:(NSArray<NSString *> *)modes		--数组里各种模式
			
	-performSelectorOnMainThread ...					--主线程
	-performSelector:  onThread ...						--指定线程
	-performSelectorInBackground: withObject:			--后台运行
	
	
	注意:在swift中performSelector()返回Unmanaged<AnyObject>! (后面会讲到, 是!后的可选类型)
	
	
	示例:
	let string: NSString = "Hello, Cocoa!"
	let selector = #selector(NSString.lowercaseStringWithLocale(_:))		--方法返回小写
	let locale = NSLocale.currentLocale()
	if let result = string.performSelector(selector, withObject: locale) {	--把str发送给locale,有可选类型返回
		print(result.takeUnretainedValue())									--这个后面会讲到.
	}
	
	
	
============= swift的class使用OC的行为============================================
如继承OC, 实现OC协议, 和其他OC的功能

1. 继承OC类
	import UIKit
	class MySwiftViewController: UIViewController {
	}
	
	
1.1 NSCoding协议
	它要求实现类必须实现init(coder:), 子类也要实现init(coder:),即required类型的
	required init(coder aDecoder: NSCoder) {
	}
	
	在从storyboard中加载or向磁盘中存档时, 使用NSUserDefault, NSKeyedArchiver类必须要完全实现此方法
	

2. 实现协议
	协议在OC中和swift中是一样的. 
	class myClass:NSObject, UITableViewDatasource,UITableViewDelegate{
	}
	
	定义类型时限定一个or多个协议:
	var item:SomeProtocol 
	var item2:protocol<UITableViewDatasource,UITableViewDelegate
	
	
	
3. initializer & deinitializer 初始构方与反初始化
	不像OC, swift中的初始化会保证所有属性都有值,增加代码安全性.
	当想清理时, 可用deinit方法替代dealloc方法. swift的deinit会在实现销毁时自动调用.
	当继承了OC类时,swift会调用super.dealloc()方法,
	
	都用swift自带init,deinit.  继承OC类销毁会自动调用super.dealoc(在deinit里调用吗? 还是啥?)
	
	
	
4. swift类名与OC API
	swift的类名基于所在模块, 不像OC的所有模块的类名不能重复(加前缀哦). (java的基于package)
	一个app就是一个模块, 所以Plan程序中的Dog 调用时就是Plan.Dog
	
	swift类名暴露在OC中, 要用全名. 如 AppName.className
	
	
	
	
5. swift与Interface Builder一起用. 
	Interface Builder即是拖拉界面, 如IBOutlet,IBAction就只在IB中起作用.
	
	5.1 与IBOutlet,IBAction一起用
		直接加到最前面修饰
		class MyViewController: UIViewController {
			@IBOutlet weak var button: UIButton!				--属性直接最前面, 属性仍有类型
			@IBOutlet var textFields: [UITextField]!
			@IBAction func buttonTapped(_: AnyObject) {			--方法直接最前面, 不影响其他部分.
				print("button tapped!")
			}
		}
		
	5.2 实时渲染:	@IBDesignable ,@IBInspectable		(需要实践)
		用在自定义的UIView子类, 可以实时看到自定义View的样子.
		
		@IBDesignable								--designable放在自定义View类名上方
		class MyCustomView: UIView {
			@IBInspectable var textColor: UIColor	--inspectable放在属性上, 就可以Inspector中修改它们了.
			@IBInspectable var iconHeight: CGFloat
		}
		
		
	
6. 指定属性的修饰(即attribute)
	
	6.1 strong和weak
		只能用于可选型class属性, 因为可设为nil + 引用类型. 非?型不能加weak,strong咯
			
	6.2 readonly和read/write
		swift中的储存属性用let,var是否只读,  计算型用get, get+set设置是否只读
		
	6.3 copy 
		OC的copy被翻译成@NSCopying, 能被copy的属性要实现NSCopying协议
		
	
	
7. 实现CoreData Managed Object的子类
	使用 @NSManaged 来告诉swift编译器此对象是coreDate存储对象的.
	
	import CoreData
	class Person: NSManagedObject {						--就是entity, @NSManaged修改元素和方法
		@NSManaged var name: String	
		@NSManaged func addFriendsObject(friend: Person)
	
	
	
--------------------使用Cocoa的数据类型 data type------------------------------------------------
1. String
	自动转为NSString
	let str1 = "hello"
	let str2:NSString = "hello"
	
	NSString可以确定转为String, 不用?的.   
	let str3 = str2 as String 

1.1 本地化
	在OC中使用NSLocalizedString的宏命令家族来本地化String, 
	包括:NSLocalizedStringFromTable ,NSLocalizedStringFromTableInBundle ,NSLocalizedStringWithDefaultValue

	let format = NSLocalizedString("Hello, %@!", comment: "Hello, {given name}!")	--相当于格式化.
	let zhCN = "你好"
	let greeting = String(format: format, arguments: [name])
	print(greeting)		--打印: Hello,你好!

	
	从App的Bundle资源中取本地化内容:
	if let path = NSBundle.mainBundle().pathForResource("Localization", 
			ofType: "strings", inDirectory: nil, forLocalization: "ja"),		--ja是日本
		let bundle = NSBundle(path: path) {
		let translation = NSLocalizedString("Hello", bundle: bundle, comment: "")
		print(translation)		--打印:こんにちは
	}
	
2. 数字
	swift会自动转换原生的数值(如Int,Float)到OC的NSNumber.
		let a = 10 
		let b:NSNumber = a 
	
	Int,UInt,Float,Double,Bool可以转换成NSNumber
	
	注意:转换前不能用于AnyObject, 在转换后成NSNumber类型了可转换成AnyObject了.
	
	
	
3. 集合类
	如NSArray转换为Array, 则	
	




